/*Copyright (C) 2014  Béguet Eric

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.*/

#include "HotKey.h"
#include "Desktop.h"
#include "DesktopApplication.h"

#define M_RIGHT         (WM_USER + 1)
#define M_LEFT          (WM_USER + 2)
#define M_EXIT          (WM_USER + 4)
#define M_REGROUP       (WM_USER + 5)
#define M_MOVE_RIGHT    (WM_USER + 6)
#define M_MOVE_LEFT     (WM_USER + 7)
#define M_GOTO          (WM_USER + 10)
#define M_MOVETO        (WM_USER + 30)


LRESULT CALLBACK WindowProcedure (HWND, UINT, WPARAM, LPARAM);
char szClassName[ ] = "SDMFakeWindow"; /*  Make the class name into a global variable  */


/*
    add Hotkeys for the application :
    Ctrl + Alt + Right key              : Go to right desktop
    Ctrl + Alt + Left key               : Go to left desktop
    Ctrl + Win key + Right key          : Move current window to right desktop
    Ctrl + Win key + Left key           : Move current window to left desktop
    Ctrl + Alt + Num pad X (1-9)        : Go to desktop number X
    Ctrl + Win key + Num pad X (1-9)    : Move current window to desktop number X
    Ctrl + Alt + X                      : Close the application and restore all windows
    Ctrl + Alt + A                      : Restore all windows

*/
std::vector<HotKey> registerHotKeys(HWND hwnd){
    std::vector<HotKey> hotkeys;
    hotkeys.push_back(HotKey(hwnd, M_RIGHT, 0x4000 | MOD_CONTROL | MOD_ALT, VK_RIGHT));
    hotkeys.push_back(HotKey(hwnd, M_LEFT , 0x4000 | MOD_CONTROL | MOD_ALT, VK_LEFT));
    hotkeys.push_back(HotKey(hwnd, M_MOVE_RIGHT, 0x4000 | MOD_CONTROL | MOD_WIN, VK_RIGHT));
    hotkeys.push_back(HotKey(hwnd, M_MOVE_LEFT , 0x4000 | MOD_CONTROL | MOD_WIN, VK_LEFT));
    for (unsigned int i = 1; i < 10; ++i)
        hotkeys.push_back(HotKey(hwnd, M_MOVETO + i, 0x4000 | MOD_CONTROL | MOD_WIN, VK_NUMPAD0 + i));
    for (unsigned int i = 1; i < 10; ++i)
        hotkeys.push_back(HotKey(hwnd, M_GOTO + i, 0x4000 | MOD_CONTROL | MOD_ALT, VK_NUMPAD0 + i));
    hotkeys.push_back(HotKey(hwnd, M_EXIT, 0x4000 | MOD_CONTROL | MOD_ALT, 0x58));       //X key
    hotkeys.push_back(HotKey(hwnd, M_REGROUP, 0x4000 | MOD_CONTROL | MOD_ALT, 0x41));    //A key
    return hotkeys;
}

void unRegisterHotKeys(const std::vector<HotKey>& hotkeys){
    for (auto h : hotkeys)
        h.unregister();
}




/*Generated by CodeBlock*/
int WINAPI WinMain (HINSTANCE hThisInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR lpszArgument,
                     int nCmdShow){
    HWND hwnd;               /* This is the handle for our window */
    MSG messages;            /* Here messages to the application are saved */
    WNDCLASSEX wincl;        /* Data structure for the windowclass */

    wincl.hInstance = hThisInstance;
    wincl.lpszClassName = szClassName;
    wincl.lpfnWndProc = WindowProcedure;      /* This function is called by windows */
    wincl.style = CS_DBLCLKS;                 /* Catch double-clicks */
    wincl.cbSize = sizeof (WNDCLASSEX);
    wincl.hIcon = LoadIcon (NULL, IDI_APPLICATION);
    wincl.hIconSm = LoadIcon (NULL, IDI_APPLICATION);
    wincl.hCursor = LoadCursor (NULL, IDC_ARROW);
    wincl.lpszMenuName = NULL;                 /* No menu */
    wincl.cbClsExtra = 0;                      /* No extra bytes after the window class */
    wincl.cbWndExtra = sizeof(DesktopApplication*); /* structure or the window instance */
    wincl.hbrBackground = (HBRUSH) COLOR_BACKGROUND;

    if (!RegisterClassEx (&wincl))
        return 0;

    hwnd = CreateWindowEx (0,           /* Extended possibilites for variation */
           szClassName,                 /* Classname */
           "Simple Desktops Manager",   /* Title Text */
           WS_OVERLAPPEDWINDOW,         /* default window */
           CW_USEDEFAULT,               /* Windows decides the position */
           CW_USEDEFAULT,               /* where the window ends up on the screen */
           0,                           /* The programs width */
           0,                           /* and height in pixels */
           HWND_DESKTOP,                /* The window is a child-window to desktop */
           NULL,                        /* No menu */
           hThisInstance,               /* Program Instance handler */
           NULL );                      /* No Window Creation data */

    auto hotkeys = registerHotKeys(hwnd);
    auto app = DesktopApplication();

    SetWindowLongPtrW(hwnd, 0, reinterpret_cast<LONG_PTR>(&app));

    while (GetMessage (&messages, NULL, 0, 0)){ /* Run the message loop. It will run until GetMessage() returns 0 */
        TranslateMessage(&messages);
        DispatchMessage(&messages);
    }

    unRegisterHotKeys(hotkeys);

    return messages.wParam;
}


/*  This function is called by the Windows function DispatchMessage()  */
LRESULT CALLBACK WindowProcedure (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam){
    DesktopApplication* app = reinterpret_cast<DesktopApplication*>(GetWindowLongPtrW(hwnd, 0));
    switch (message){
        case  WM_HOTKEY:
            if (wParam == M_RIGHT)
                app->right();
            else if (wParam == M_LEFT)
                app->left();
            else if (wParam == M_MOVE_RIGHT)
                app->moveRight();
            else if (wParam == M_MOVE_LEFT)
                app->moveLeft();
            else if (wParam >= M_GOTO && wParam <= M_GOTO + 9)
                app->goTo(wParam - M_GOTO - 1);
            else if (wParam >= M_MOVETO && wParam <= M_MOVETO + 9)
                app->moveTo(wParam - M_MOVETO - 1);
            else if (wParam == M_REGROUP)
                app->displayAll();
            else if (wParam == M_EXIT){
                app->displayAll();
                PostQuitMessage (0);
            }
            break;
        case WM_DESTROY:
            PostQuitMessage (0);       /* send a WM_QUIT to the message queue */
            break;
        default:                      /* for messages that we don't deal with */
            return DefWindowProc (hwnd, message, wParam, lParam);
    }
    return 0;
}


